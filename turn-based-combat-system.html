<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clearly and Rask's Mechabellum Unit Combat Simulator</title>
    (its close!)
    <link href="https://unpkg.com/tabulator-tables@6.2.1/dist/css/tabulator.min.css" rel="stylesheet">
    <style>
        body { 
            font-family: sans-serif; 
            background-color: #f0f2f5; 
            color: #333;
            line-height: 1.6;
        }
        .container { 
            max-width: 1200px; 
            margin: 40px auto; 
            padding: 20px; 
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1 { 
            text-align: center; 
            color: #2c3e50; 
            margin-bottom: 20px;
        }
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        button { 
            padding: 12px 24px; 
            background-color: #3498db; 
            color: white; 
            cursor: pointer; 
            border: none;
            border-radius: 4px; 
            font-size: 16px; 
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        #resultsTable { 
            margin-top: 20px;
        }
        /* Custom styles for Tabulator */
        .tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
            text-align: center;
        }
        .tabulator .tabulator-tableHolder .tabulator-placeholder {
            text-align: center;
        }
        .tabulator-row .tabulator-cell {
            text-align: center;
        }
        .winner {
            color: #27ae60;
            font-weight: bold;
        }
        .loser {
            color: #c0392b;
        }
        .draw {
            color: #f39c12;
        }
        #version-number {
            position: absolute; /* Positions the element relative to the nearest positioned ancestor or the document body */
            top: 10px;        /* 10 pixels from the top edge */
            right: 10px;       /* 10 pixels from the right edge */
            color: green;      /* Sets the text color to green */
            font-weight: bold; /* Makes the text bold */
            font-family: sans-serif; /* A clear, readable font */
            text-shadow: 1px 1px 2px #00000080; /* A subtle shadow for contrast */
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="version-number">Season 5 Game version 1.8, Tool Version 2.0</div>
        <h1>Clearly and Rask's Mechabellum Unit Combat Simulator</h1>
        <p style="text-align: center;">Simulating every unit against every other unit.</p>
        <div class="controls">
            <button id="startButton">Start Simulation</button>
            <span id="sim-spinner" style="display:none; margin-left:10px;"></span>
        </div>
        <div id="resultsTable"></div>
    </div>
    <div class="controls">
        <button id="export-button">Export to CSV (click after table generated)</button>
    </div>
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.2.1/dist/js/tabulator.min.js"></script>
    <script>
        const unitData = [
            {name: 'Crawler', health: 263, armor: 0, damage: 79, frequency: 0.6, range: 0, splashRadius: 0, speed: 16, totalSubunits: 24, depth: 10, width: 40, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 100},
            {name: 'Fang', health: 117, armor: 0, damage: 63, frequency: 1.5, range: 75, splashRadius: 0, speed: 6, totalSubunits: 18, depth: 10, width: 40, isFlier: false, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 100},
            {name: 'Hound', health: 897, armor: 0, damage: 246, frequency: 2.4, range: 70, splashRadius: 6, speed: 10, totalSubunits: 5, depth: 10, width: 32, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 100},
            {name: 'Void Eye', health: 1509, armor: 0, damage: 1008, frequency: 3.2, range: 100, splashRadius: 0, speed: 8, totalSubunits: 3, depth: 10, width: 32, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 100},
            {name: 'Arclight', health: 4813, armor: 0, damage: 347, frequency: 0.9, range: 95, splashRadius: 7, speed: 7, totalSubunits: 1, depth: 10, width: 16, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 100},
            {name: 'Marksman', health: 1622, armor: 0, damage: 2329, frequency: 3.1, range: 140, splashRadius: 0, speed: 8, totalSubunits: 1, depth: 10, width: 16, isFlier: false, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 100},
            {name: 'Mustang', health: 343, armor: 0, damage: 36, frequency: 0.4, range: 95, splashRadius: 0, speed: 16, totalSubunits: 12, depth: 10, width: 40, isFlier: false, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Sledgehammer', health: 3478, armor: 0, damage: 608, frequency: 4.5, range: 95, splashRadius: 5, speed: 7, totalSubunits: 5, depth: 10, width: 40, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Stormcaller', health: 1149, armor: 0, damage: 772, frequency: 6.6, range: 180, splashRadius: 5.5, speed: 6, totalSubunits: 4, depth: 10, width: 40, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Steel Ball', health: 4571, armor: 0, damage: 0, frequency: 0.2, range: 45, splashRadius: 0, speed: 16, totalSubunits: 4, depth: 10, width: 40, isFlier: false, canAttackFliers: false, isBeamWeapon: true, minDamage: 2, maxDamage: 2605, rampUpTime: 6, undergroundMovement:false, cost: 200},
            {name: 'Fire Badger', health: 4589, armor: 0, damage: 28, frequency: 0.1, range: 70, splashRadius: 9, speed: 9, totalSubunits: 3, depth: 10, width: 40, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Sabertooth', health: 15541, armor: 0, damage: 7858, frequency: 3.4, range: 95, splashRadius: 5, speed: 8, totalSubunits: 1, depth: 15, width: 24, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Tarantula', health: 13273, armor: 0, damage: 496, frequency: 0.6, range: 80, splashRadius: 5, speed: 8, totalSubunits: 1, depth: 15, width: 24, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Rhino', health: 19297, armor: 0, damage: 3560, frequency: 0.9, range: 0, splashRadius: 6, speed: 16, totalSubunits: 1, depth: 15, width: 24, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Hacker', health: 3249, armor: 0, damage: 585, frequency: 0.3, range: 110, splashRadius: 0, speed: 8, totalSubunits: 1, depth: 15, width: 24, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Wasp', health: 311, armor: 0, damage: 202, frequency: 1.4, range: 50, splashRadius: 0, speed: 16, totalSubunits: 12, depth: 10, width: 40, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Phoenix', health: 1420, armor: 0, damage: 2892, frequency: 3.4, range: 120, splashRadius: 0, speed: 16, totalSubunits: 2, depth: 10, width: 32, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Phantom Ray', health: 3412, armor: 0, damage: 1087, frequency: 3, range: 65, splashRadius: 3, speed: 16, totalSubunits: 3, depth: 10, width: 40, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 200},
            {name: 'Wraith', health: 14551, armor: 0, damage: 392, frequency: 1.6, range: 60, splashRadius: 8, speed: 10, totalSubunits: 1, depth: 15, width: 24, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 300},
            {name: 'Scorpion', health: 18632, armor: 0, damage: 10650, frequency: 4.5, range: 100, splashRadius: 15, speed: 7, totalSubunits: 1, depth: 15, width: 24, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 300},
            {name: 'Farseer', health: 11991, armor: 0, damage: 1348, frequency: 2, range: 125, splashRadius: 8, speed: 16, totalSubunits: 1, depth: 15, width: 24, isFlier: false, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 300},
            {name: 'Vulcan', health: 33566, armor: 0, damage: 88, frequency: 0.1, range: 95, splashRadius: 15, speed: 6, totalSubunits: 1, depth: 20, width: 32, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 400},
            {name: 'Melting Point', health: 30907, armor: 0, damage: 0, frequency: 0.2, range: 115, splashRadius: 3, speed: 6, totalSubunits: 1, depth: 20, width: 32, isFlier: false, canAttackFliers: true, isBeamWeapon: true, minDamage: 2, maxDamage: 7952, rampUpTime: 6, undergroundMovement:false, cost: 400},
            {name: 'Fortress', health: 43938, armor: 0, damage: 6524, frequency: 1.8, range: 100, splashRadius: 5, speed: 6, totalSubunits: 1, depth: 20, width: 32, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 400},
            {name: 'Sandworm', health: 48645, armor: 0, damage: 9352, frequency: 2.5, range: 0, splashRadius: 12, speed: 16, totalSubunits: 1, depth: 20, width: 32, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:true, cost: 400},
            {name: 'Raiden', health: 18349, armor: 0, damage: 5570, frequency: 4.6, range: 110, splashRadius: 0, speed: 10, totalSubunits: 1, depth: 20, width: 32, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 400},
            {name: 'Overlord', health: 20323, armor: 0, damage: 4474, frequency: 4.6, range: 120, splashRadius: 7, speed: 10, totalSubunits: 1, depth: 25, width: 40, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 500},
            {name: 'War Factory', health: 113593, armor: 0, damage: 7520, frequency: 1.8, range: 100, splashRadius: 4.5, speed: 6, totalSubunits: 1, depth: 35, width: 56, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 800},
            {name: 'Abyss', health: 66955, armor: 0, damage: 3859, frequency: 4, range: 100, splashRadius: 10, speed: 10, totalSubunits: 1, depth: 35, width: 56, isFlier: true, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 800},
            {name: 'Mountain', health: 136657, armor: 0, damage: 5899, frequency: 2, range: 100, splashRadius: 5, speed: 6, totalSubunits: 1, depth: 35, width: 56, isFlier: false, canAttackFliers: false, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 800},
            {name: 'Typhoon', health: 9529, armor: 0, damage: 88, frequency: 0.2, range: 100, splashRadius: 5, speed: 9, totalSubunits: 1, depth: 10, width: 32, isFlier: false, canAttackFliers: true, isBeamWeapon: false, minDamage: 0, maxDamage: 0, rampUpTime: 0, undergroundMovement:false, cost: 300}
        ];
        
        function startSimulation() {
            // Show spinner
            const spinner = document.getElementById('sim-spinner');
            spinner.innerHTML = '<svg width="20" height="20" viewBox="0 0 50 50"><circle cx="25" cy="25" r="20" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-dasharray="31.415, 31.415" transform="rotate(72.0001 25 25)"><animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/></circle></svg>';
            spinner.style.display = '';
            setTimeout(() => {
                const results = [];
                for (let i = 0; i < unitData.length; i++) {
                    for (let j = 0; j < unitData.length; j++) {
                        if (i === j) continue;
                        const attackerUnit = unitData[i];
                        const defenderUnit = unitData[j];
                        let defenderMultiplier = 1;
                        let defenderNameDisplay = defenderUnit.name;
                        if (attackerUnit.cost > defenderUnit.cost) {
                            defenderMultiplier = Math.floor(attackerUnit.cost / defenderUnit.cost);
                            if (defenderMultiplier < 1) defenderMultiplier = 1;
                            defenderNameDisplay = defenderUnit.name + (defenderMultiplier > 1 ? `*${defenderMultiplier}` : '');
                        }
                        const visualDefender = defenderMultiplier > 1
                            ? { ...defenderUnit, totalSubunits: defenderUnit.totalSubunits * defenderMultiplier, cost: defenderUnit.cost * defenderMultiplier, width: defenderUnit.width * defenderMultiplier }
                            : defenderUnit;
                        const battleResult = simulateBattle(attackerUnit, visualDefender);
                        results.push({
                            attacker: attackerUnit.name,
                            defender: defenderNameDisplay,
                            defenderMultiplier: defenderMultiplier,
                            ...battleResult
                        });
                    }
                }
                displayResults(results);
                spinner.style.display = 'none';
            }, 50);
        }

        function createUnit(unitType) {
                        let initialTimeToFire;
            
            // All units except the Sandworm attack immediately.
            // Setting their timer to frequency allows the loop's check to pass on the first frame.
            if (unitType.name !== 'Sandworm') {
                initialTimeToFire = unitType.frequency; 
            }
            // The Sandworm has a delay, so its timer must charge up from 0.
            else {
                initialTimeToFire = 0; 
            }
            return {
                ...unitType,
                subunits: unitType.totalSubunits,
                currentHealth: unitType.totalSubunits * unitType.health,
                subunitHealths: Array(unitType.totalSubunits).fill(unitType.health),
                timeToFire: Array(unitType.totalSubunits).fill(initialTimeToFire),
                damageRampTimers: Array(unitType.totalSubunits).fill(0),
                targetIndexes: Array(unitType.totalSubunits).fill(-1),
                initialHealth: unitType.totalSubunits * unitType.health,
                shotCounts: new Array(unitType.totalSubunits).fill(0),
            };
        }

        function calculateBeamDamage(unit, rampUpTimer) {
            if (unit.rampUpTime <= 0) {
                return unit.maxDamage; // Avoid division by zero
            }
            
            // Calculate damage increase based on time, not shots
            const damageIncreasePerSecond = (unit.maxDamage - unit.minDamage) / unit.rampUpTime;
            
            // The damage is the minimum of max damage and the damage at the current time
            const currentDamage = unit.minDamage + (damageIncreasePerSecond * rampUpTimer);
            
            return Math.min(unit.maxDamage, currentDamage);
        }

        // Find multiple distinct living targets
        function findMultipleTargets(subunitHealths, count) {
            const targets = [];
            const availableTargets = [];
            for (let i = 0; i < subunitHealths.length; i++) {
                if (subunitHealths[i] > 0) {
                    availableTargets.push(i);
                }
            }   
            // Shuffle the available targets to ensure random selection
            for (let i = availableTargets.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableTargets[i], availableTargets[j]] = [availableTargets[j], availableTargets[i]];
            } 
            // Select up to 'count' targets
            for (let i = 0; i < Math.min(count, availableTargets.length); i++) {
                targets.push(availableTargets[i]);
            }
            // Pad with -1 if fewer than 'count' targets are available
            while (targets.length < count) {
                targets.push(-1);
            }
            return targets;
        }

        // New function to apply damage to a specific subunit, handling death
        function applyDamageToSubunit(unit, subunitIndex, damage) {
            if (unit.subunitHealths[subunitIndex] > 0) {
                unit.subunitHealths[subunitIndex] -= damage;
                if (unit.subunitHealths[subunitIndex] <= 0) {
                    unit.subunitHealths[subunitIndex] = 0;
                    unit.subunits--;
                }
            }
        }

        function performAttack(attacker, defender, targetIndex, damageToApply, timeStep) {
            // Check if the primary target is still alive
            if (defender.subunitHealths[targetIndex] > 0) {
                // Apply direct damage to the primary target
                applyDamageToSubunit(defender, targetIndex, damageToApply);

                // Check for splash damage
                if (attacker.splashRadius > 0) {
                    // The splash damage amount is either the ramped-up beam damage or the fixed damage
                    const splashDamage = attacker.isBeamWeapon ? damageToApply : attacker.damage;
                    // So half a circle is a good approximation for splash area. However we're already attacking 1 unit above so we're checking how many ADDITOINAL units
                    // we're hitting here. Especially for small numbers of subunits we absolutely aren't hitting several units at once. A melting point IS NOT hitting 2 phantom rays with its beam.
                    // So we're rounding down instead of up. We're also assuming all extra groups of units are lined up lengthwise along the way so we aren't so we aren't assuming 8 groups of crawlers
                    // are sitting on top of each other when attacking a war factory. Now with bigger splashes with a ton of units, maybe it makes more sense to round up. But for small subunits, rounding
                    // down is more accurate.
                    const subunitsHit = Math.floor((0.5 * Math.PI * Math.pow(attacker.splashRadius, 2)) / ((defender.depth * defender.width) / defender.totalSubunits));
                    
                    let damagedCount = 0;
                    for (let i = 0; i < defender.totalSubunits && damagedCount < subunitsHit; i++) {
                        // Ensure we don't damage the primary target twice and the subunit is alive
                        if (i !== targetIndex && defender.subunitHealths[i] > 0) {
                            applyDamageToSubunit(defender, i, splashDamage);
                            damagedCount++;
                        }
                    }
                }
            }
        }
        function findNearestLivingTarget(targets) {
            let nearestIndex = -1;
            let nearestDistance = Infinity;
            for (let i = 0; i < targets.length; i++) {
                // Assuming a distance calculation based on subunit position
                // This is a placeholder; you will need to implement this part.
                const distance = calculateSubunitDistance(i); 

                if (targets[i] > 0 && distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestIndex = i;
                }
            }
            return nearestIndex;
        }
        // A function to find the index of a new, alive target
        function findNewTarget(subunitHealths) {
            for (let i = 0; i < subunitHealths.length; i++) {
                if (subunitHealths[i] > 0) {
                    return i;
                }
            }
            return -1; // No valid target found
        }
        
        function getResult(winnerUnit, loserUnit, time, initialDistance) {
            let winner = 'Draw';
            let survivalRatio = 0;
            let winnerSubunits = 0;

            if (winnerUnit.subunits > 0) {
                winner = winnerUnit.name;
                // Calculate survival ratio based on the sum of remaining health
                const winnerInitialHealth = winnerUnit.totalSubunits * winnerUnit.health;
                survivalRatio = winnerUnit.subunitHealths.reduce((total, health) => total + health, 0) / winnerInitialHealth;
                winnerSubunits = winnerUnit.subunits;
            } else if (loserUnit.subunits > 0) {
                winner = loserUnit.name;
                const loserInitialHealth = loserUnit.totalSubunits * loserUnit.health;
                survivalRatio = loserUnit.subunitHealths.reduce((total, health) => total + health, 0) / loserInitialHealth;                winnerSubunits = loserUnit.subunits;
            }
            return {
                winner: winner,
                time: time.toFixed(2),
                survivalRatio: (survivalRatio * 100).toFixed(2),
                winnerSubunits: winnerSubunits,
                isNoContest: false,
                startingDistance: initialDistance.toFixed(2)
            };
        }

        function logCustomDebug(attacker, defender, time, damageThisTimeStep, totalDamageDoneByAttacker, totalDamageDoneByDefender, distance, currentAttackerBeamDamage) {
            if (attacker.name === 'Steel Ball' && defender.name === 'Tarantula') {
                console.log(`--- Time: ${time.toFixed(2)}s ---`);
                console.log(`Distance: ${distance.toFixed(2)}`);
                console.log(`Steel Ball Subunit Health: ${attacker.subunitHealths.map(h => h.toFixed(2)).join(', ')}`);
                console.log(`Tarantula Health: ${defender.health.toFixed(2)}`);
                console.log(`Damage Done This Time Slice (Steel Ball): ${damageThisTimeStep.attacker.toFixed(2)}`);
                console.log(`Damage Done This Time Slice (Tarantula): ${damageThisTimeStep.defender.toFixed(2)}`);
                console.log(`Total Damage Done By Steel Ball: ${totalDamageDoneByAttacker.toFixed(2)}`);
                console.log(`Total Damage Done By Tarantula: ${totalDamageDoneByDefender.toFixed(2)}`);
                console.log(`Steel Ball Per-Subunit Damage: [${currentAttackerBeamDamage.map(d => d.toFixed(2)).join(', ')}]`);
                console.log(`--- End of Time Slice ---`);
            }
        }

        function simulateBattle(attackerType, defenderType) {
            const defenderCantAttackFlier = attackerType.isFlier && !defenderType.canAttackFliers && !defenderType.isFlier;
            const attackerCantAttackFlier = !attackerType.isFlier && defenderType.isFlier && !attackerType.canAttackFliers;
            const initialDistance = Math.max(attackerType.range, defenderType.range) + 1;
            let currentAttackerBeamDamage = [];
            let currentDefenderBeamDamage = [];
            let totalDamageDoneByAttacker = 0;
            let totalDamageDoneByDefender = 0;
            if (attackerCantAttackFlier) {
                const winnerType = defenderType;
                return {
                    winner: winnerType.name,
                    time: 0,
                    survivalRatio: 100,
                    winnerSubunits: winnerType.totalSubunits,
                    isNoContest: true,
                    startingDistance: initialDistance.toFixed(2)
                };
            }

            let attacker = createUnit(attackerType);
            let defender = createUnit(defenderType);
            let time = 0;
            const timeStep = 0.1;
            let distance = initialDistance;
            let debugLog = [];

            while (attacker.subunits > 0 && defender.subunits > 0) {
                let isAttackerInRange = attacker.range >= distance;
                let isDefenderInRange = defender.range >= distance;
                let attackerIsMoving = !isAttackerInRange;
                let defenderIsMoving = !isDefenderInRange;
                
                // This variable is now correctly used to track damage per time slice
                let damageThisTimeStep = {
                    attacker: 0,
                    defender: 0
                };
                let currentAttackerBeamDamage = new Array(attacker.totalSubunits).fill(0);
                let currentDefenderBeamDamage = new Array(defender.totalSubunits).fill(0);

                if (attackerIsMoving && defenderIsMoving) {
                    distance = Math.max(0, distance - (attacker.speed + defender.speed) * timeStep);
                } else if (attackerIsMoving) {
                    distance = Math.max(0, distance - attacker.speed * timeStep);
                } else if (defenderIsMoving) {
                    distance = Math.max(0, distance - defender.speed * timeStep);
                }

             // --- START: ATTACKER'S CORRECTED ATTACK LOGIC ---
            if (isAttackerInRange && !attackerCantAttackFlier) {
                let targetedTargets = [];
                for (let i = 0; i < attacker.totalSubunits; i++) {
                    if (attacker.subunitHealths[i] > 0) {
                        let targetIndex = attacker.targetIndexes[i];

                        // This is the key change: only reset the timer if a NEW target is found.
                        if (targetIndex === -1 || defender.subunitHealths[targetIndex] <= 0) {
                            let availableTargets = defender.subunitHealths.map((health, index) => ({ health, index }))
                                .filter(target => target.health > 0 && !targetedTargets.includes(target.index));

                            if (availableTargets.length > 0) {
                                let newTarget = findNewTarget(availableTargets.map(t => t.health));
                                targetIndex = availableTargets[newTarget].index;
                                attacker.targetIndexes[i] = targetIndex;
                                targetedTargets.push(targetIndex);
                            } else {
                                targetIndex = findNewTarget(defender.subunitHealths);
                                attacker.targetIndexes[i] = targetIndex;
                            }

                            if (attacker.isBeamWeapon) {
                                attacker.damageRampTimers[i] = 0; // The reset is here now
                            }
                        }
                        
                        if (targetIndex !== -1) {
                            const canDamageDefender = !(defender.undergroundMovement && defenderIsMoving);
                            
                            if (canDamageDefender) {
                                attacker.timeToFire[i] += timeStep;
                                
                                if (attacker.isBeamWeapon) {
                                    // For beam weapons, always increment the ramp-up timer while firing
                                    attacker.damageRampTimers[i] += timeStep;
                                }

                                if (attacker.timeToFire[i] >= attacker.frequency) {
                                    attacker.timeToFire[i] = 0;
                                    let damageToApply = attacker.damage;

                                    if (attacker.isBeamWeapon) {
                                        damageToApply = calculateBeamDamage(attacker, attacker.damageRampTimers[i]);
                                        // Do NOT reset the timer here
                                        currentAttackerBeamDamage[i] = damageToApply;
                                    }

                                    if (attacker.name === 'Raiden') {
                                        const targets = findMultipleTargets(defender.subunitHealths, 3);
                                        targets.forEach(idx => {
                                            if (idx !== -1) {
                                                performAttack(attacker, defender, idx, damageToApply, timeStep);
                                                damageThisTimeStep.attacker += damageToApply;
                                            }
                                        });
                                    } else {
                                        performAttack(attacker, defender, targetIndex, damageToApply, timeStep);
                                        damageThisTimeStep.attacker += damageToApply;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // --- END: ATTACKER'S CORRECTED ATTACK LOGIC ---
            // --- START: DEFENDER'S CORRECTED ATTACK LOGIC ---
            if (isDefenderInRange && !defenderCantAttackFlier) {
                let targetedTargets = [];
                for (let i = 0; i < defender.totalSubunits; i++) {
                    if (defender.subunitHealths[i] > 0) {
                        let targetIndex = defender.targetIndexes[i];
                        
                        // The key change is here for the defender
                        if (targetIndex === -1 || attacker.subunitHealths[targetIndex] <= 0) {
                            let availableTargets = attacker.subunitHealths.map((health, index) => ({ health, index }))
                                .filter(target => target.health > 0 && !targetedTargets.includes(target.index));

                            if (availableTargets.length > 0) {
                                let newTarget = findNewTarget(availableTargets.map(t => t.health));
                                targetIndex = availableTargets[newTarget].index;
                                defender.targetIndexes[i] = targetIndex;
                                targetedTargets.push(targetIndex);
                            } else {
                                targetIndex = findNewTarget(attacker.subunitHealths);
                                defender.targetIndexes[i] = targetIndex;
                            }

                            if (defender.isBeamWeapon) {
                                defender.damageRampTimers[i] = 0; // The reset is here now
                            }
                        }
                        
                        if (targetIndex !== -1) {
                            const canDamageAttacker = !(attacker.undergroundMovement && attackerIsMoving);

                            if (canDamageAttacker) {
                                defender.timeToFire[i] += timeStep;
                                
                                if (defender.isBeamWeapon) {
                                    // For beam weapons, always increment the ramp-up timer while firing
                                    defender.damageRampTimers[i] += timeStep;
                                }
                                
                                if (defender.timeToFire[i] >= defender.frequency) {
                                    defender.timeToFire[i] = 0;
                                    let damageToApply = defender.damage;

                                    if (defender.isBeamWeapon) {
                                        damageToApply = calculateBeamDamage(defender, defender.damageRampTimers[i]);
                                        // Do NOT reset the timer here
                                        currentDefenderBeamDamage[i] = damageToApply;
                                    }

                                    if (defender.name === 'Raiden') {
                                        const targets = findMultipleTargets(attacker.subunitHealths, 3);
                                        targets.forEach(idx => {
                                            if (idx !== -1) {
                                                performAttack(defender, attacker, idx, damageToApply, timeStep);
                                                damageThisTimeStep.defender += damageToApply;
                                            }
                                        });
                                    } else {
                                        performAttack(defender, attacker, targetIndex, damageToApply, timeStep);
                                        damageThisTimeStep.defender += damageToApply;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // --- END: DEFENDER'S CORRECTED ATTACK LOGIC ---

                totalDamageDoneByAttacker += damageThisTimeStep.attacker;
                totalDamageDoneByDefender += damageThisTimeStep.defender;

                // Call the debug function after both sides have attacked
                //logCustomDebug(attacker, defender, time, damageThisTimeStep, totalDamageDoneByAttacker, totalDamageDoneByDefender, distance, currentAttackerBeamDamage);
                debugLog.push({
                    time: time.toFixed(2),
                    attackerSubunits: attacker.subunits,
                    defenderSubunits: defender.subunits,
                    distance: distance.toFixed(2),
                    damageThisTimeStep: {
                        attacker: damageThisTimeStep.attacker.toFixed(2),
                        defender: damageThisTimeStep.defender.toFixed(2)
                    }
                });
                
                if (attacker.subunits === 0 || defender.subunits === 0) {
                    break;
                }
                time += timeStep;
                if (time > 1000) break;
            }

            const battleResult = getResult(attacker.subunits > 0 ? attacker : defender, attacker.subunits > 0 ? defender : attacker, time, initialDistance);
            battleResult.debugLog = debugLog;
            return battleResult;
        }
 
        
        function displayResults(results) {
            const COUNTER_TIME = 13.58; //Previously calculated average time it takes for 1 unit to kill another
            const tableData = results.map(result => {
                // Extract canonical defender name (remove multiplier)
                const match = result.defender.match(/^(.*?)(\*\d+)?$/);
                const defenderCanonical = match ? match[1] : result.defender;
                let timeDisplay = result.isNoContest ? 'No Contest' : `${result.time} s`;
                // Winner color logic: green for attacker win, yellow for uncontested air win, red for defender win
                let winnerClass = 'winner';
                let winnerStyle = '';
                if (result.winner === result.attacker) {
                    winnerStyle = 'color: #27ae60; font-weight: bold;'; // green
                } else {
                    winnerStyle = 'color: #c0392b; font-weight: bold;'; // red
                }
                // Counter: attacker wins AND (survival > 50% OR time < 13.58s)
                let isCounter = false;
                if (
                    result.winner === result.attacker &&
                    !result.isNoContest &&
                    (parseFloat(result.survivalRatio) > 50 && parseFloat(result.time) < COUNTER_TIME)
                ) {
                    isCounter = true;
                }
                return {
                    attacker: result.attacker,
                    defender: result.defender,
                    defenderCanonical: defenderCanonical,
                    winner: result.winner,
                    winnerClass: winnerClass,
                    winnerStyle: winnerStyle,
                    survivalRatio: result.survivalRatio,
                    survivedSubunits: result.winnerSubunits,
                    time: timeDisplay,
                    startingDistance: result.startingDistance,
                    isCounter: isCounter,
                    debugLog: result.debugLog
                };
            });

            const table = new Tabulator("#resultsTable", {
                data: tableData,
                layout: "fitDataStretch",
                columns: [
                    // This entire object defines the first column
                    {
                        title:  "Log",
                        formatter: function(cell, formatterParams, onRendered) {
                            const rowData = cell.getRow().getData();
                            if (rowData.debugLog && rowData.debugLog.length > 0) {
                                return '<i class="toggle-button" style="cursor: pointer;">▶</i>';
                            } else {
                                return '';
                            }
                        },
                        width: 40,
                        minWidth: 40,
                        hozAlign: "center",
                        resizable: false,
                        headerSort: false,
                        // The cellClick event must be inside the column's object
                        cellClick: function(e, cell) {
                            const row = cell.getRow();
                            const tableHolder = row.getElement().querySelector('.nested-table-holder');
                            if (tableHolder) {
                                const isVisible = tableHolder.style.display !== 'none';
                                tableHolder.style.display = isVisible ? 'none' : '';
                                cell.getElement().querySelector('.toggle-button').textContent = isVisible ? '▶' : '▼';
                            }
                        }
                    },
                    {title: "Attacker", field: "attacker", sorter: "string", headerFilter: "input"},
                    {title: "Defender", field: "defender", sorter: "string", headerFilter: "input"},
                    {title: "Winner", field: "winner", sorter: "string", formatter: function(cell) {
                        const rowData = cell.getRow().getData();
                        const winner = cell.getValue();
                        const winnerClass = rowData.winnerClass;
                        return `<span class="${winnerClass}">${winner}</span>`;
                    }, headerFilter: "input"},
                    {title: "Survival Ratio (%)", field: "survivalRatio", sorter: "number"},
                    {title: "Survived Subunits", field: "survivedSubunits", sorter: "number"},
                    {title: "Starting Distance", field: "startingDistance", sorter: "number"},
                    {title: "Time", field: "time", sorter: "string"},
                    {title: "Counter", field: "isCounter", sorter: "boolean", formatter: function(cell) {
                        return cell.getValue() ? '✅' : '';
                    }}
                ],
                rowFormatter: function(row) {
                    const data = row.getData();
                    if (data.debugLog && data.debugLog.length > 0) {
                        const tableHolder = document.createElement("div");
                        tableHolder.className = 'nested-table-holder';
                        tableHolder.style.cssText = "padding: 10px; background-color: #f5f5f5; display: none;";
                        const subTable = document.createElement("div");
                        tableHolder.appendChild(subTable);
                        row.getElement().appendChild(tableHolder);

                        new Tabulator(subTable, {
                            data: data.debugLog,
                            layout: "fitColumns",
                            columns: [
                                {title: "Time", field: "time"},
                                {title: "Attacker Subunits", field: "attackerSubunits"},
                                {title: "Defender Subunits", field: "defenderSubunits"},
                                {title: "Distance", field: "distance"},
                            ]
                        });
                    }
                }
            });
             // Place the event listener here, after the table is defined
            document.getElementById('export-button').addEventListener('click', function() {
                table.download("csv", "battle_results.csv");
            });
            
            // --- Output countersData object below the table ---
            // Build countersData: { unit: { weakness: [..], strong_counter: [..] } }
            // Use canonical names for all units
            const allUnits = Array.from(new Set([
                ...tableData.map(r => r.attacker),
                ...tableData.map(r => r.defenderCanonical)
            ])).sort((a, b) => a.localeCompare(b));
            const countersData = {};
            allUnits.forEach(unit => {
                // Weakness: units that are counters to this unit
                const weakness = tableData
                    .filter(r => r.defenderCanonical === unit && r.isCounter)
                    .map(r => r.attacker)
                    .filter((v, i, a) => a.indexOf(v) === i)
                    .sort((x, y) => x.localeCompare(y));
                // Strong counter: units this unit is a counter against
                const strong_counter = tableData
                    .filter(r => r.attacker === unit && r.isCounter)
                    .map(r => r.defenderCanonical)
                    .filter((v, i, a) => a.indexOf(v) === i)
                    .sort((x, y) => x.localeCompare(y));
                countersData[unit] = { weakness, strong_counter, synergizes: [] };
            });

            // Render below the table
            let output = '<h3 style="margin-top:2em;">countersData = {<br>';
            Object.entries(countersData).forEach(([unit, obj]) => {
                output += `&nbsp;&nbsp;"${unit}": { "weakness": [${obj.weakness.map(u => `\"${u}\"`).join(', ')}], "strong_counter": [${obj.strong_counter.map(u => `\"${u}\"`).join(', ')}], "synergizes": [${obj.synergizes.map(u => `\"${u}\"`).join(', ')}] },<br>`;
            });
            output += '};</h3>';
            const div = document.createElement('div');
            div.innerHTML = output;
            document.querySelector('.container').appendChild(div);
        }
        // Keep this at the very end of the <script> block, after all functions are defined
        document.addEventListener('DOMContentLoaded', (event) => {
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.addEventListener('click', startSimulation);
            }
        });
    </script>
</body>
</html>